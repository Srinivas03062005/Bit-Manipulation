DIVIDEND = 22
DIVISOR = 3 (NEVER BE 0)
IN THE RANGE [-2^31,2^31-1]
RETURN THE INTEGER VALUE

3+3+3+3+3+3+3
TOTAL 7

SUM=0,COUNT=0;

WHILE(SUM+DIVISOR<=DIVIDEND)
{
	COUNT++;
	SUM=SUM+DIVISOR;
}
PRINT COUNT;


TC IS O(DIVIDEND)
WORST CASE IF 1
 
------------
OPTIMIZATION
------------
22 3
(3*7)
3*(2^2+2^1+2^0)
(3*2^2)+(3*2^1)+(3*2^0)

12       6       3
SO REMOVE THESE



22
3*2^0=3
3*2^1=6
3*2^2=12
3*2^3=24   CROSSES THE VALUE

22-12
10
3*2^0=3
3*2^1=6
3*2^2=12    CROSSES THE VALUE

10-6
4
3*2^0=3
3*2^1=6   CROSSES THE VALUE

4-3
1
3*2^0=3    CROSSES THE VALUE

2^2+2^1+2^0=7

PSEUDO CODE FOR THIS

FUNC(DIVIDEND,DIVISOR)
{
  
  IF(DIVIDEND==DIVISOR) RETURN 1
  
  SIGN=TRUE||+VE
  IF(DIVIDEND>=0 && DIVISOR<0)  SIGN=FALSE||-VE
  ELSE IF(DIVIDEND<0 && DIVISOR>0) SIGN=FALSE||-VE
  
N=(ABS)DIVIDEND   D=(ABS)DIVISOR    //WHY ABS IS CONVERTS -VE TO +VE
ANS=0
WHILE(N>=D)
{
	COUNT=0
	WHILE(N>=(D<<(COUNT+1)))   ->   (D<<COUNT+1)==D*2^COUNT+1
	{
		COUNT++;
	}
	
	ANS=ANS+(1<<COUNT)  -> (1<<COUNT)==2^COUNT
	N=N-(D*(1<<COUNT))
}
  IF(ANS>=2^31 && SIGN==TRUE)
  {
  	RETURN INT_MAX;
  }
  ELSE IF(ANS>=2^31 && SIGN==FALSE)
  {
  	RETURN INT_MIN;
  }
  RETURN SIGN?ANS:(-1*ANS);
}
